---
title: "Assignment 04 — Lightcast Job Market Analysis"
author:
  - name: "Othmane Elouardi"
    affiliations:
      - id: bu
        name: "Boston University"
        city: "Boston"
        state: "MA"
date: 2025-10-08
number-sections: true
format:
  html:
    theme:
      light: lux
      dark: slate
    toc: true
    toc-depth: 3
    toc-location: right
    smooth-scroll: true
    code-fold: true
    code-tools: true
    code-line-numbers: true
    highlight-style: a11y
    page-layout: article
    css: styles.css
    grid:
      body-width: 900px     
      margin-width: 280px   
execute:
  echo: true
  warning: false
  error: false
  freeze: auto
jupyter: env
---

# Introduction

This report analyzes job postings from the **Lightcast Job Market dataset**, exploring salary trends, employment types, skill demand, and more.  
All visualizations are interactive, allowing you to hover and explore insights dynamically.

---

# Load the Dataset

```{python}
#| label: load-data
#| echo: true
#| message: false
#| warning: false

import pandas as pd
import numpy as np
from pathlib import Path

DATA_PATH = Path("data/lightcast_job_postings.csv")

# 1) File sanity check
assert DATA_PATH.exists(), f"CSV not found at {DATA_PATH.resolve()}"

# 2) Robust read (handles wide schema + mixed types)
df = pd.read_csv(
    DATA_PATH,
    low_memory=False,        # avoid dtype guessing issues
    parse_dates=False,       # we’ll parse dates explicitly later
    dtype=str                # keep raw text first; coerce below
)

print("✅ Dataset loaded successfully!")
print(f"Rows: {len(df):,}  |  Columns: {len(df.columns):,}")

# 3) Quick schema peek (first 12 columns to keep output tidy)
preview_cols = list(df.columns[:12])
display(df[preview_cols].head(5))

# 4) Helpful normalized aliases (so later sections work even if column names vary a bit)
#    Feel free to add more aliases if your CSV headers differ.
ALIASES = {
    "EMPLOYMENT_TYPE_NAME": ["EMPLOYMENT_TYPE_NAME", "EMPLOYMENT_TYPE", "EMP_TYPE"],
    "SALARY_FROM":          ["SALARY_FROM", "SAL_FROM", "MIN_SALARY", "SALARY_MIN"],
    "SALARY_TO":            ["SALARY_TO", "SAL_TO", "MAX_SALARY", "SALARY_MAX"],
    "INDUSTRY_NAME":        ["INDUSTRY_NAME", "NAICS2_NAME", "NAICS_NAME"],
    "JOB_TITLE":            ["JOB_TITLE", "TITLE_NAME", "TITLE"],
    "POSTED":               ["POSTED", "POSTED_DATE", "DATE_POSTED"],
    "REMOTE_TYPE_NAME":     ["REMOTE_TYPE_NAME", "REMOTE_TYPE", "REMOTE"],
    "SKILL_NAME":           ["SKILL_NAME", "SKILL"]
}

def pick(existing: list[str], candidates: list[str]) -> str | None:
    for c in candidates:
        if c in existing:
            return c
    return None

use = {k: pick(df.columns.tolist(), v) for k, v in ALIASES.items()}
print("Resolved column names:", use)

# 5) Minimal cleaning: numbers/dates we’ll need later
if use["SALARY_FROM"]:
    df["SALARY_FROM_NUM"] = pd.to_numeric(df[use["SALARY_FROM"]], errors="coerce")
if use["SALARY_TO"]:
    df["SALARY_TO_NUM"] = pd.to_numeric(df[use["SALARY_TO"]], errors="coerce")
if use["POSTED"]:
    df["POSTED_DATE"] = pd.to_datetime(df[use["POSTED"]], errors="coerce", utc=True).dt.date

# 6) Tiny health report
health = {
    "non-null rows (any)": int(df.dropna(how="all").shape[0]),
    "with salary_from": int(df["SALARY_FROM_NUM"].notna().sum() if "SALARY_FROM_NUM" in df else 0),
    "with salary_to": int(df["SALARY_TO_NUM"].notna().sum() if "SALARY_TO_NUM" in df else 0),
    "with posted_date": int(df["POSTED_DATE"].notna().sum() if "POSTED_DATE" in df else 0),
}
health

```

# Salary Distribution by Employment Type


```{python}
#| label: salary-by-employment-type
#| echo: true
#| message: false
#| warning: false

import plotly.express as px

# usable columns
col_emp = use.get("EMPLOYMENT_TYPE_NAME")
col_sal = "SALARY_FROM_NUM" if "SALARY_FROM_NUM" in df else use.get("SALARY_FROM")

if col_emp and col_sal:
    # Drop missing values for clean plotting
    subset = df.dropna(subset=[col_emp, col_sal])
    
    # filter extreme outliers for clearer visualization
    q_low, q_high = subset[col_sal].quantile([0.05, 0.95])
    subset = subset[(subset[col_sal] >= q_low) & (subset[col_sal] <= q_high)]

    # Create the boxplot
    fig = px.box(
        subset,
        x=col_emp,
        y=col_sal,
        color=col_emp,
        title="Salary Distribution by Employment Type",
        template="plotly_dark",
        color_discrete_sequence=px.colors.qualitative.Bold
    )

    fig.update_layout(
        xaxis_title="Employment Type",
        yaxis_title="Salary (From)",
        title_font=dict(size=20, family="Inter", color="#1f6feb"),
        font=dict(family="Inter", size=13),
        plot_bgcolor="rgba(0,0,0,0)",
        paper_bgcolor="rgba(0,0,0,0)",
        margin=dict(t=60, l=60, r=40, b=60)
    )

    fig.show()
else:
    print("❌ Required columns not found for salary distribution plot.")
```

## ✏️ Explanation

The box plot shows how salary levels vary across different employment types. Full-time positions generally have higher median salaries and a wider pay range, reflecting greater earning potential but also more variability.
In contrast, part-time and contract roles exhibit lower median salaries with tighter ranges, suggesting more consistency but fewer high-paying opportunities.




# Salary Distribution by Industry

```{python}

#| label: salary-by-industry
#| echo: true
#| message: false
#| warning: false

import numpy as np
import pandas as pd
import plotly.express as px

# Resolve column names dynamically (using your earlier `use` dict if present)
col_ind = (use.get("INDUSTRY_NAME") if "use" in locals() else
           ("INDUSTRY_NAME" if "INDUSTRY_NAME" in df.columns else None))
col_sal = ("SALARY_FROM_NUM" if "SALARY_FROM_NUM" in df.columns else
           (use.get("SALARY_FROM") if "use" in locals() else
            ("SALARY_FROM" if "SALARY_FROM" in df.columns else None)))

if col_ind and col_sal:
    # Keep only rows with industry and salary
    dfi = df.dropna(subset=[col_ind, col_sal]).copy()

    # Pick top-N industries by posting volume to keep the chart readable
    TOP_N = 10
    top_inds = (dfi[col_ind]
                .value_counts(dropna=False)
                .nlargest(TOP_N)
                .index)
    dfi = dfi[dfi[col_ind].isin(top_inds)]

    # Trim extreme outliers globally for clarity (5th–95th percentile)
    ql, qh = dfi[col_sal].quantile([0.05, 0.95])
    dfi = dfi[(dfi[col_sal] >= ql) & (dfi[col_sal] <= qh)]

    # Order industries by median salary (descending)
    medians = dfi.groupby(col_ind)[col_sal].median().sort_values(ascending=False)
    category_order = medians.index.tolist()

    # Box plot (clean + interactive)
    fig = px.box(
        dfi,
        x=col_ind,
        y=col_sal,
        color=col_ind,
        category_orders={col_ind: category_order},
        title="Salary Distribution by Industry (Top 10 by Postings)",
        template="plotly_dark",
        color_discrete_sequence=px.colors.qualitative.Bold,
        points=False  # hide raw points to keep it tidy
    )

    fig.update_layout(
        xaxis_title="Industry",
        yaxis_title="Salary (From)",
        title_font=dict(size=20, family="Inter", color="#1f6feb"),
        font=dict(family="Inter", size=13),
        xaxis_tickangle=35,
        plot_bgcolor="rgba(0,0,0,0)",
        paper_bgcolor="rgba(0,0,0,0)",
        margin=dict(t=60, l=60, r=40, b=80),
        showlegend=False
    )

    fig.show()
else:
    print("❌ Required columns not found for industry salary plot.")




```

```{python}

#| label: salary-by-industry-stats
#| echo: false
#| message: false
#| warning: false

if col_ind and col_sal:
    stats = (df.dropna(subset=[col_ind, col_sal])
               .groupby(col_ind)[col_sal]
               .agg(N="size", mean="mean", median="median", p25=lambda s: s.quantile(0.25),
                    p75=lambda s: s.quantile(0.75))
               .sort_values("median", ascending=False)
               .head(10))

    # Round for neatness
    display(stats.round(0))


```

## ✏️ Explanation

The chart shows that salary levels vary notably across industries. The Information and Accommodation and Food Services sectors exhibit the highest median and upper-range salaries, suggesting strong compensation potential in these fields.
Meanwhile, industries like Administrative Support and Retail Trade tend to offer lower median salaries, reflecting more standardized pay structures and fewer high-paying roles.


# Job Posting Trends Over Time



```{python}





```



# Top 10 Job Titles by Count


```{python}





```



# Remote vs On-Site Job Postings


```{python}





```


# Skill Demand Analysis by Industry (Stacked Bar Chart)


```{python}





```


# Salary Analysis by ONET Occupation Type (Bubble Chart)

```{python}





```


# Career Pathway Trends (Sankey Diagram)

```{python}





```



