{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Assignment 04 — Lightcast Job Market Analysis\"\n",
        "author:\n",
        "  - name: \"Othmane Elouardi\"\n",
        "    affiliations:\n",
        "      - id: bu\n",
        "        name: \"Boston University\"\n",
        "        city: \"Boston\"\n",
        "        state: \"MA\"\n",
        "date: 2025-10-08\n",
        "number-sections: true\n",
        "format:\n",
        "  html:\n",
        "    theme:\n",
        "      light: lux\n",
        "      dark: slate\n",
        "    toc: true\n",
        "    toc-depth: 3\n",
        "    toc-location: right\n",
        "    smooth-scroll: true\n",
        "    code-fold: true\n",
        "    code-tools: true\n",
        "    code-line-numbers: true\n",
        "    highlight-style: a11y\n",
        "    page-layout: article\n",
        "    css: styles.css\n",
        "    grid:\n",
        "      body-width: 900px     \n",
        "      margin-width: 280px   \n",
        "execute:\n",
        "  echo: true\n",
        "  warning: false\n",
        "  error: false\n",
        "  freeze: auto\n",
        "jupyter: env\n",
        "---\n",
        "\n",
        "# Introduction\n",
        "\n",
        "This report analyzes job postings from the **Lightcast Job Market dataset**, exploring salary trends, employment types, skill demand, and more.  \n",
        "All visualizations are interactive, allowing you to hover and explore insights dynamically.\n",
        "\n",
        "---\n",
        "\n",
        "# Load the Dataset"
      ],
      "id": "95b06deb"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: load-data\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "from pathlib import Path\n",
        "\n",
        "DATA_PATH = Path(\"data/lightcast_job_postings.csv\")\n",
        "\n",
        "# 1) File sanity check\n",
        "assert DATA_PATH.exists(), f\"CSV not found at {DATA_PATH.resolve()}\"\n",
        "\n",
        "# 2) Robust read (handles wide schema + mixed types)\n",
        "df = pd.read_csv(\n",
        "    DATA_PATH,\n",
        "    low_memory=False,        # avoid dtype guessing issues\n",
        "    parse_dates=False,       # we’ll parse dates explicitly later\n",
        "    dtype=str                # keep raw text first; coerce below\n",
        ")\n",
        "\n",
        "print(\"✅ Dataset loaded successfully!\")\n",
        "print(f\"Rows: {len(df):,}  |  Columns: {len(df.columns):,}\")\n",
        "\n",
        "# 3) Quick schema peek (first 12 columns to keep output tidy)\n",
        "preview_cols = list(df.columns[:12])\n",
        "display(df[preview_cols].head(5))\n",
        "\n",
        "# 4) Helpful normalized aliases (so later sections work even if column names vary a bit)\n",
        "#    Feel free to add more aliases if your CSV headers differ.\n",
        "ALIASES = {\n",
        "    \"EMPLOYMENT_TYPE_NAME\": [\"EMPLOYMENT_TYPE_NAME\", \"EMPLOYMENT_TYPE\", \"EMP_TYPE\"],\n",
        "    \"SALARY_FROM\":          [\"SALARY_FROM\", \"SAL_FROM\", \"MIN_SALARY\", \"SALARY_MIN\"],\n",
        "    \"SALARY_TO\":            [\"SALARY_TO\", \"SAL_TO\", \"MAX_SALARY\", \"SALARY_MAX\"],\n",
        "    \"INDUSTRY_NAME\":        [\"INDUSTRY_NAME\", \"NAICS2_NAME\", \"NAICS_NAME\"],\n",
        "    \"JOB_TITLE\":            [\"JOB_TITLE\", \"TITLE_NAME\", \"TITLE\"],\n",
        "    \"POSTED\":               [\"POSTED\", \"POSTED_DATE\", \"DATE_POSTED\"],\n",
        "    \"REMOTE_TYPE_NAME\":     [\"REMOTE_TYPE_NAME\", \"REMOTE_TYPE\", \"REMOTE\"],\n",
        "    \"SKILL_NAME\":           [\"SKILL_NAME\", \"SKILL\"]\n",
        "}\n",
        "\n",
        "def pick(existing: list[str], candidates: list[str]) -> str | None:\n",
        "    for c in candidates:\n",
        "        if c in existing:\n",
        "            return c\n",
        "    return None\n",
        "\n",
        "use = {k: pick(df.columns.tolist(), v) for k, v in ALIASES.items()}\n",
        "print(\"Resolved column names:\", use)\n",
        "\n",
        "# 5) Minimal cleaning: numbers/dates we’ll need later\n",
        "if use[\"SALARY_FROM\"]:\n",
        "    df[\"SALARY_FROM_NUM\"] = pd.to_numeric(df[use[\"SALARY_FROM\"]], errors=\"coerce\")\n",
        "if use[\"SALARY_TO\"]:\n",
        "    df[\"SALARY_TO_NUM\"] = pd.to_numeric(df[use[\"SALARY_TO\"]], errors=\"coerce\")\n",
        "if use[\"POSTED\"]:\n",
        "    df[\"POSTED_DATE\"] = pd.to_datetime(df[use[\"POSTED\"]], errors=\"coerce\", utc=True).dt.date\n",
        "\n",
        "# 6) Tiny health report\n",
        "health = {\n",
        "    \"non-null rows (any)\": int(df.dropna(how=\"all\").shape[0]),\n",
        "    \"with salary_from\": int(df[\"SALARY_FROM_NUM\"].notna().sum() if \"SALARY_FROM_NUM\" in df else 0),\n",
        "    \"with salary_to\": int(df[\"SALARY_TO_NUM\"].notna().sum() if \"SALARY_TO_NUM\" in df else 0),\n",
        "    \"with posted_date\": int(df[\"POSTED_DATE\"].notna().sum() if \"POSTED_DATE\" in df else 0),\n",
        "}\n",
        "health"
      ],
      "id": "load-data",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Salary Distribution by Employment Type\n"
      ],
      "id": "3d5e25b8"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: salary-by-employment-type\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "import plotly.express as px\n",
        "\n",
        "# usable columns\n",
        "col_emp = use.get(\"EMPLOYMENT_TYPE_NAME\")\n",
        "col_sal = \"SALARY_FROM_NUM\" if \"SALARY_FROM_NUM\" in df else use.get(\"SALARY_FROM\")\n",
        "\n",
        "if col_emp and col_sal:\n",
        "    # Drop missing values for clean plotting\n",
        "    subset = df.dropna(subset=[col_emp, col_sal])\n",
        "    \n",
        "    # filter extreme outliers for clearer visualization\n",
        "    q_low, q_high = subset[col_sal].quantile([0.05, 0.95])\n",
        "    subset = subset[(subset[col_sal] >= q_low) & (subset[col_sal] <= q_high)]\n",
        "\n",
        "    # Create the boxplot\n",
        "    fig = px.box(\n",
        "        subset,\n",
        "        x=col_emp,\n",
        "        y=col_sal,\n",
        "        color=col_emp,\n",
        "        title=\"Salary Distribution by Employment Type\",\n",
        "        template=\"plotly_dark\",\n",
        "        color_discrete_sequence=px.colors.qualitative.Bold\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        xaxis_title=\"Employment Type\",\n",
        "        yaxis_title=\"Salary (From)\",\n",
        "        title_font=dict(size=20, family=\"Inter\", color=\"#1f6feb\"),\n",
        "        font=dict(family=\"Inter\", size=13),\n",
        "        plot_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        paper_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        margin=dict(t=60, l=60, r=40, b=60)\n",
        "    )\n",
        "\n",
        "    fig.show()\n",
        "else:\n",
        "    print(\"❌ Required columns not found for salary distribution plot.\")"
      ],
      "id": "salary-by-employment-type",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## ✏️ Explanation\n",
        "\n",
        "The box plot shows how salary levels vary across different employment types. Full-time positions generally have higher median salaries and a wider pay range, reflecting greater earning potential but also more variability.\n",
        "In contrast, part-time and contract roles exhibit lower median salaries with tighter ranges, suggesting more consistency but fewer high-paying opportunities.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Salary Distribution by Industry"
      ],
      "id": "f41b1a8f"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: salary-by-industry\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "\n",
        "# Resolve column names dynamically (using your earlier `use` dict if present)\n",
        "col_ind = (use.get(\"INDUSTRY_NAME\") if \"use\" in locals() else\n",
        "           (\"INDUSTRY_NAME\" if \"INDUSTRY_NAME\" in df.columns else None))\n",
        "col_sal = (\"SALARY_FROM_NUM\" if \"SALARY_FROM_NUM\" in df.columns else\n",
        "           (use.get(\"SALARY_FROM\") if \"use\" in locals() else\n",
        "            (\"SALARY_FROM\" if \"SALARY_FROM\" in df.columns else None)))\n",
        "\n",
        "if col_ind and col_sal:\n",
        "    # Keep only rows with industry and salary\n",
        "    dfi = df.dropna(subset=[col_ind, col_sal]).copy()\n",
        "\n",
        "    # Pick top-N industries by posting volume to keep the chart readable\n",
        "    TOP_N = 10\n",
        "    top_inds = (dfi[col_ind]\n",
        "                .value_counts(dropna=False)\n",
        "                .nlargest(TOP_N)\n",
        "                .index)\n",
        "    dfi = dfi[dfi[col_ind].isin(top_inds)]\n",
        "\n",
        "    # Trim extreme outliers globally for clarity (5th–95th percentile)\n",
        "    ql, qh = dfi[col_sal].quantile([0.05, 0.95])\n",
        "    dfi = dfi[(dfi[col_sal] >= ql) & (dfi[col_sal] <= qh)]\n",
        "\n",
        "    # Order industries by median salary (descending)\n",
        "    medians = dfi.groupby(col_ind)[col_sal].median().sort_values(ascending=False)\n",
        "    category_order = medians.index.tolist()\n",
        "\n",
        "    # Box plot (clean + interactive)\n",
        "    fig = px.box(\n",
        "        dfi,\n",
        "        x=col_ind,\n",
        "        y=col_sal,\n",
        "        color=col_ind,\n",
        "        category_orders={col_ind: category_order},\n",
        "        title=\"Salary Distribution by Industry (Top 10 by Postings)\",\n",
        "        template=\"plotly_dark\",\n",
        "        color_discrete_sequence=px.colors.qualitative.Bold,\n",
        "        points=False  # hide raw points to keep it tidy\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        xaxis_title=\"Industry\",\n",
        "        yaxis_title=\"Salary (From)\",\n",
        "        title_font=dict(size=20, family=\"Inter\", color=\"#1f6feb\"),\n",
        "        font=dict(family=\"Inter\", size=13),\n",
        "        xaxis_tickangle=35,\n",
        "        plot_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        paper_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        margin=dict(t=60, l=60, r=40, b=80),\n",
        "        showlegend=False\n",
        "    )\n",
        "\n",
        "    fig.show()\n",
        "else:\n",
        "    print(\"❌ Required columns not found for industry salary plot.\")\n"
      ],
      "id": "salary-by-industry",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: salary-by-industry-stats\n",
        "#| echo: false\n",
        "#| warning: false\n",
        "\n",
        "if col_ind and col_sal:\n",
        "    stats = (df.dropna(subset=[col_ind, col_sal])\n",
        "               .groupby(col_ind)[col_sal]\n",
        "               .agg(N=\"size\", mean=\"mean\", median=\"median\", p25=lambda s: s.quantile(0.25),\n",
        "                    p75=lambda s: s.quantile(0.75))\n",
        "               .sort_values(\"median\", ascending=False)\n",
        "               .head(10))\n",
        "\n",
        "    # Round for neatness\n",
        "    display(stats.round(0))\n"
      ],
      "id": "salary-by-industry-stats",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## ✏️ Explanation\n",
        "\n",
        "The chart shows that salary levels vary notably across industries. The Information and Accommodation and Food Services sectors exhibit the highest median and upper-range salaries, suggesting strong compensation potential in these fields.\n",
        "Meanwhile, industries like Administrative Support and Retail Trade tend to offer lower median salaries, reflecting more standardized pay structures and fewer high-paying roles.\n",
        "\n",
        "\n",
        "# Job Posting Trends Over Time\n"
      ],
      "id": "8df2f4d7"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: job-posting-trends\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "\n",
        "# Ensure date column exists and is parsed\n",
        "if \"POSTED\" in df.columns:\n",
        "    df[\"POSTED_DATE\"] = pd.to_datetime(df[\"POSTED\"], errors=\"coerce\")\n",
        "\n",
        "    # Aggregate daily counts\n",
        "    trend = (df.dropna(subset=[\"POSTED_DATE\"])\n",
        "               .groupby(\"POSTED_DATE\")\n",
        "               .size()\n",
        "               .reset_index(name=\"Job_Postings\"))\n",
        "\n",
        "    # Create line chart\n",
        "    fig = px.line(\n",
        "        trend,\n",
        "        x=\"POSTED_DATE\",\n",
        "        y=\"Job_Postings\",\n",
        "        title=\"Job Posting Trends Over Time\",\n",
        "        template=\"plotly_dark\",\n",
        "        color_discrete_sequence=[\"#37f3c0\"]\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        xaxis_title=\"Posted Date\",\n",
        "        yaxis_title=\"Number of Job Postings\",\n",
        "        font=dict(family=\"Inter\", size=13),\n",
        "        title_font=dict(size=20, family=\"Inter\", color=\"#1f6feb\"),\n",
        "        hovermode=\"x unified\",\n",
        "        plot_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        paper_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        margin=dict(t=60, l=60, r=40, b=80),\n",
        "    )\n",
        "\n",
        "    fig.update_traces(line=dict(width=2.5))\n",
        "    fig.show()\n",
        "else:\n",
        "    print(\"❌ 'POSTED' column not found.\")\n"
      ],
      "id": "job-posting-trends",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## ✏️ Explanation\n",
        "\n",
        "The trend line reveals noticeable fluctuations in job posting activity, indicating that hiring demand changes frequently over time. Peaks suggest periods of intensified recruitment, possibly driven by seasonal hiring cycles or new project launches, while the dips represent slower hiring phases.\n",
        "Overall, the data highlights a dynamic job market with recurring surges in posting volume.\n",
        "\n",
        "\n",
        "# Top 10 Job Titles by Count\n"
      ],
      "id": "1351e56e"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: top-job-titles\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "\n",
        "if \"TITLE_NAME\" in df.columns:\n",
        "    # Count occurrences and select top 10\n",
        "    top_jobs = df[\"TITLE_NAME\"].value_counts().nlargest(10)\n",
        "\n",
        "    # Create bar chart\n",
        "    fig = px.bar(\n",
        "        x=top_jobs.index,\n",
        "        y=top_jobs.values,\n",
        "        title=\"Top 10 Job Titles by Count\",\n",
        "        text_auto=True,\n",
        "        color=top_jobs.values,\n",
        "        color_continuous_scale=\"tealgrn\",\n",
        "        template=\"plotly_dark\"\n",
        "    )\n",
        "\n",
        "    fig.update_layout(\n",
        "        xaxis_title=\"Job Title\",\n",
        "        yaxis_title=\"Number of Postings\",\n",
        "        font=dict(family=\"Inter\", size=13),\n",
        "        title_font=dict(size=20, family=\"Inter\", color=\"#1f6feb\"),\n",
        "        xaxis_tickangle=40,\n",
        "        plot_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        paper_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        margin=dict(t=60, l=60, r=40, b=100)\n",
        "    )\n",
        "\n",
        "    fig.show()\n",
        "else:\n",
        "    print(\"❌ 'TITLE_NAME' column not found in dataset.\")\n"
      ],
      "id": "top-job-titles",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## ✏️ Explanation\n",
        "The chart shows that Data Analyst is by far the most frequently posted job title, indicating a high market demand for data-focused professionals. Other roles like Unclassified, Enterprise Architect, and Data Engineer also appear prominently, reflecting the growing need for both analytical and technical expertise in data-driven organizations.\n",
        "\n",
        "# Remote vs On-Site Job Postings\n"
      ],
      "id": "d24e30df"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| label: remote-vs-onsite\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "\n",
        "import plotly.express as px\n",
        "\n",
        "if \"REMOTE_TYPE_NAME\" in df.columns:\n",
        "    remote_counts = df[\"REMOTE_TYPE_NAME\"].value_counts().reset_index()\n",
        "    remote_counts.columns = [\"Remote Type\", \"Count\"]\n",
        "\n",
        "    fig = px.pie(\n",
        "        remote_counts,\n",
        "        names=\"Remote Type\",\n",
        "        values=\"Count\",\n",
        "        title=\"Remote vs On-Site Job Postings\",\n",
        "        color_discrete_sequence=px.colors.qualitative.Pastel\n",
        "    )\n",
        "\n",
        "    fig.update_traces(textposition=\"inside\", textinfo=\"percent+label\")\n",
        "    fig.update_layout(\n",
        "        title_font=dict(size=20, family=\"Inter\", color=\"#1f6feb\"),\n",
        "        font=dict(family=\"Inter\", size=14),\n",
        "        showlegend=False,\n",
        "        paper_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        plot_bgcolor=\"rgba(0,0,0,0)\"\n",
        "    )\n",
        "\n",
        "    fig.show()\n",
        "else:\n",
        "    print(\"❌ 'REMOTE_TYPE_NAME' column not found in dataset.\")\n"
      ],
      "id": "remote-vs-onsite",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## ✏️ Explanation\n",
        "The chart shows that a large majority of job postings do not specify a remote type, while around 17% explicitly offer remote positions. A smaller portion of listings are hybrid or partially remote, indicating that while remote work is available, most employers still emphasize on-site or unspecified work arrangements.\n",
        "\n",
        "\n",
        "# Skill Demand Analysis by Industry (Stacked Bar Chart)\n"
      ],
      "id": "03ccca27"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: skill-demand-by-industry\n",
        "#| echo: true\n",
        "#| warning: false\n",
        "#| message: false\n",
        "\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import plotly.express as px\n",
        "import ast\n",
        "\n",
        "# --- 1) Robustly parse SKILLS_NAME into lists, then explode ---\n",
        "def to_list(value):\n",
        "    \"\"\"Convert SKILLS_NAME cells to a list of clean strings.\"\"\"\n",
        "    if pd.isna(value) or value == \"\":\n",
        "        return []\n",
        "    if isinstance(value, list):\n",
        "        return [str(v).strip() for v in value]\n",
        "    s = str(value).strip()\n",
        "\n",
        "    # If it looks like a Python list literal, parse safely\n",
        "    if s.startswith(\"[\") and s.endswith(\"]\"):\n",
        "        try:\n",
        "            parsed = ast.literal_eval(s)\n",
        "            return [str(v).strip() for v in parsed if str(v).strip()]\n",
        "        except Exception:\n",
        "            pass\n",
        "\n",
        "    # Fall back to common delimiters\n",
        "    for sep in [\"|\", \";\", \" / \", \"/\", \",\"]:\n",
        "        if sep in s:\n",
        "            return [t.strip() for t in s.split(sep) if t.strip()]\n",
        "\n",
        "    # Otherwise treat the whole thing as one skill\n",
        "    return [s]\n",
        "\n",
        "required = {\"NAICS2_NAME\", \"SKILLS_NAME\"}\n",
        "if required.issubset(df.columns):\n",
        "    skills = df.loc[:, [\"NAICS2_NAME\", \"SKILLS_NAME\"]].copy()\n",
        "    skills[\"SKILLS_NAME\"] = skills[\"SKILLS_NAME\"].apply(to_list)\n",
        "    skills = skills.explode(\"SKILLS_NAME\", ignore_index=True)\n",
        "    skills = skills[skills[\"SKILLS_NAME\"].notna() & (skills[\"SKILLS_NAME\"] != \"\")]\n",
        "    skills.rename(columns={\"NAICS2_NAME\": \"Industry\", \"SKILLS_NAME\": \"Skill\"}, inplace=True)\n",
        "\n",
        "    # --- 2) Limit to top skills & top industries (keeps chart readable) ---\n",
        "    TOP_SKILLS = 8\n",
        "    TOP_INDS   = 10\n",
        "    top_skills = skills[\"Skill\"].value_counts().head(TOP_SKILLS).index\n",
        "    top_inds   = skills[\"Industry\"].value_counts().head(TOP_INDS).index\n",
        "    skills_top = skills[skills[\"Skill\"].isin(top_skills) & skills[\"Industry\"].isin(top_inds)]\n",
        "\n",
        "    agg = (skills_top\n",
        "           .groupby([\"Industry\", \"Skill\"])\n",
        "           .size()\n",
        "           .reset_index(name=\"Count\"))\n",
        "\n",
        "    # --- 3) Horizontal stacked bar (better for long labels) ---\n",
        "    fig = px.bar(\n",
        "        agg,\n",
        "        x=\"Count\",\n",
        "        y=\"Industry\",\n",
        "        color=\"Skill\",\n",
        "        orientation=\"h\",\n",
        "        barmode=\"stack\",\n",
        "        title=\"Skill Demand by Industry (Top Skills & Industries)\",\n",
        "        color_discrete_sequence=px.colors.qualitative.Vivid\n",
        "    )\n",
        "    fig.update_layout(\n",
        "        height=640,\n",
        "        font=dict(family=\"Inter\", size=13),\n",
        "        title_font=dict(size=20, family=\"Inter\", color=\"#1f6feb\"),\n",
        "        xaxis_title=\"Skill Count\",\n",
        "        yaxis_title=\"Industry\",\n",
        "        yaxis=dict(categoryorder=\"total ascending\"),\n",
        "        plot_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        paper_bgcolor=\"rgba(0,0,0,0)\",\n",
        "        legend_title_text=\"Skill\",\n",
        "        margin=dict(l=10, r=10, t=60, b=10)\n",
        "    )\n",
        "    fig.show()\n",
        "else:\n",
        "    missing = required - set(df.columns)\n",
        "    print(f\"❌ Missing required columns: {sorted(missing)}\")\n"
      ],
      "id": "73abef00",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## ✏️ Explanation\n",
        "\n",
        "The chart shows that professional, scientific, and technical services industries have the highest demand for skills, especially in communication, data analysis, and leadership.\n",
        "Across most industries, soft skills like communication and problem-solving appear as consistently essential, highlighting their broad value alongside technical expertise such as SQL and computer science.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Salary Analysis by ONET Occupation Type (Bubble Chart)"
      ],
      "id": "3185b370"
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Career Pathway Trends (Sankey Diagram)"
      ],
      "id": "e507e4bf"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "env",
      "language": "python",
      "display_name": "Python (env)",
      "path": "/home/ubuntu/.local/share/jupyter/kernels/env"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}